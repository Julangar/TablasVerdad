# -*- coding: utf-8 -*-
"""calculadora_booleana

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FRS5wmqsel9hDS0ZN5SQcch8i-OtC1qG
"""

import itertools
import re
from tabulate import tabulate
from collections import OrderedDict

simbolos = {'∧', '∨', '→', '↔'} 

expresion = '(A ∧ B) ↔ (~A ∨ C) ↔ (A ∨ D)'


def contenido_parentesis(string):
    stack = []
    for i, char in enumerate(string):
        if char == '(':
            stack.append(i)
        elif char == ')' and stack:
            start = stack.pop()
            yield (len(stack), string[start + 1: i])


def condicional(p, q):
    return False if p and not q else True


def bicondicional(p, q):
    return (True if p and q
        else True if not p and not q 
        else False)


def and_func(p, q):
    return p and q


def or_func(p, q):
    return p or q


def negacion(p):
    return not p


def aplicar_negacion(string):
    nuevo_string = string[:]
    for i, char in enumerate(string):
        if char == '~':
            try:
                sig_char = string[i+1]
                num = int(sig_char)
                negated = str(int(negacion(num)))
                nuevo_string = nuevo_string.replace('~'+string[i+1], negated)
            except:
                pass
    return nuevo_string


def eval_logica(string):
    string = string.replace(' ', '')
    string = aplicar_negacion(string)
    operadores = {
        '∧': and_func,
        '∨': or_func,
        '→': condicional,
        '↔': bicondicional
        }
    for i, char in enumerate(string):
        if char in operadores:
            valor_1, valor_2 = int(string[i-1]), int(string[i+1])
            boolean = operadores[char](valor_1, valor_2)
    try:
        return int(boolean) 
    except:
        return int(string) 


def get_variables(expresion):
    variables = {char for char in expresion if char.isalpha()}
    variables = list(variables)
    variables.sort()
    return variables


def diccionario_variables(expresion):
    variables = get_variables(expresion)
    combo_list = []
    for booleans in itertools.product([True, False], repeat = len(variables)):
        int_bool = [int(x) for x in booleans] 
        combo_list.append(dict(zip(variables, int_bool)))
    return combo_list


def remplazar_variables(string, valores):
    for variable in valores:
        bool_string = str(valores[variable])
        string = string.replace(variable, bool_string)
    return string


def simplificar(eval_expresion):
    lista_brackets = list(contenido_parentesis(eval_expresion))
    if not lista_brackets:
        return str(eval_logica(eval_expresion))
    ultimo_nivel = max([i for (i,j) in lista_brackets]) 
    for nivel, string in lista_brackets:
        if nivel == ultimo_nivel:
            string_booleano = str(eval_logica(string))
            eval_expresion = eval_expresion.replace('('+string+')', string_booleano)
    return eval_expresion


def solucionar(eval_expresion):
    while len(eval_expresion) > 1:
        eval_expresion = simplificar(eval_expresion)
    return int(eval_expresion)


def get_tabla_verdad(expresion):
    if expresion[0] != '(':
        expresion = '('+expresion+')' 
    variables = get_variables(expresion)
    combo_list = diccionario_variables(expresion)
    tabla_verdad = []
    for truth_values in combo_list:
        valued_expresion = remplazar_variables(expresion, truth_values)
        ordered_truth_values = OrderedDict(sorted(truth_values.items()))
        answer = solucionar(valued_expresion)
        tabla_verdad.append(list(ordered_truth_values.values()) + [answer])
    return tabla_verdad

while True: 
  print("simbolos = {'∧', '∨', '→', '↔'} ")
  print('Ingrese la expresión lógica: ')
  expresion = input()
  variables = get_variables(expresion)
  tabla_verdad = get_tabla_verdad(expresion)
  print(
  """ 
  Expresion Logica: 

  {}

  Tabla de Verdad: 

  {}

  """.format(
      expresion,
      tabulate(tabla_verdad, headers=variables + ['Resultado'])
  )) 

  repetir = int(input("Si desea realizar otro calculo ingrese 0, sino ingrese 1: "))
  if(repetir == 1):
      break